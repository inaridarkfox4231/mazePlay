// 未確定マスで、上下左右を見たとき、1のマスがあるものを考える（他はとりあえずスルー）
// その1のマスの上下左右を見て0が2つ以上あったらその1のマスは0にできない。
// 0が1つもない場合も。1つだけの時、そこを割る（0にする）。そして、未確定マスから作った迷路をそこでつなげる感じ。
// で、valueもちゃんと計算。そのうえで、割った先の0マスのvalueに対し、壊した壁のvalueをそれ+1にして、そこから先の
// マスのvalueもそれ+2をすべて加えて再計算する感じかなぁ。
// ていうかvalueの初期値を+2にすればいいんでしょ・・createMazeにvalueの初期値の情報を加えましょう。デフォルトは0で。
// createPath(3, 3, 0)から始める。createMaze(3, 3)はcreatePath(3, 3, 0)から始める。
// そして-1が残ったら、そこを走査して、上下左右で1マスがある-1マスのうち、それらの1マスの中に上下左右で
// 0マスがひとつだけのものがあるものを探す。あればその0マスのvalueに対して1マスのvalueを+1とし、
// originの-1マスを(x, y)としてcreateMaze(x, y, v + 2)する。んー・・

// 詳細
// restマスで、その上下左右の1マスのうち、上下左右の0マスがひとつしかないもの、が、あるもの、を、探す。
// すべてのrestマスが条件を満たさないならrestマスをすべて1にしてbreak.
// あるならうち一つを選び、該当する1マスを0にしてvalueを隣接0マスのvalueをv_0としてv_0+1に設定
// そしてもとのrestマスに対しcreatePath(マス.x, マス.y, v_0+2)を実行する。
// そして次のループに移る。

// うまくいった・・？？のか？？
// 失敗。また明日。

// isZero > 1に戻したらうまくいった。自分を信じないとだめだね。

// とりあえずこれで迷路ができるみたい
// いろいろあったけど何とかなってよかった
// 中を歩いてみたい
// 円でブラインドしても面白そう
// 敵を用意して倒したい
// 単純にゴール見つけて進むだけでも面白そう
// 運要素が高すぎるのは自分が面白くないから嫌だ
// さすがに32×24ともなると若干時間かかってる・・なんか工夫が必要かも

// 斜向かいが気になる？0を置くときに、というか候補を探すときに、
// 具体的にはcheck_1でisZero > 1のとき1確定にしてfalse返してる、ここで、
// isZero === 1であっても、4つの斜め方向の中に0確定があって、その方向のライン上が1確定の場合は
// 1にしてfalse. どういうことかというと・・
// for(let k = 0; k < 4; k++){
//   let m = (k + 1) % 4;
//   dx[k]とdx[m]とdx[k] + dx[m]が1, 1, 0のときhit!
// }
// ってやればそういうのを排除できる、はず。

// 位置はcellとそこからのずれ（0～1）で表現する。十字キーでdiffに変化が生じる。
// directionの方向に十字キーを押すとdiffが増え逆方向ならdiffが減る。
// 直交する方向の場合は、diffが0に近いか1に近い場合でなければ何も起こらない感じ。
// 0に近くてfromマスの上が空いてる時の上キー操作と下が空いてる時の下キー操作でdiffが減る
// 1に近くてtoマスの上が空いてる時の上キー操作と下が空いてる時の下キー操作でdiffが増える
// diffが0を下回るときに、fromマスのdirと反対方向が1確定ならその値はdiffで固定される感じ
// そこでたとえば下が空いてて下キーとか押すとtoマスとdirが然るべく変化して計算に反映されて・・

// ショットいろいろ用意したいよね
// あとtoをなくしたい。fromだけで計算できる。

// 未探索を暗くするとか。

// スタートの所。B1Fと表示しつつ暗くしてmoveはしない感じ。
// 実行中・・終わったら、はじく。

// 敵を倒すには
// HPがないとね
// ショットがないとね
// ショットを作り出すメソッド
// 当たり判定
// 壁などに当たった際の挙動
// HPが0になったら倒したことにする
// 衝突判定は衝突リストを出力するだけにする（そこであれこれ書かない）（リストの処理は別立て）

// 階段で上に行く処理は重なった時のイベント発生として処理する感じ
// イベントはボードに書き込む
// 前段階として、ビットの1のところを通過可能フラグにする。つまり、通過可能マスはすべて2進表示で
// 1の位が1(奇数)になるということ。判定も===1から&1に切り替える。
// で、さしあたりゴールのフラグを3にしてplayerのfromのボードが3になったらクリア判定。
// playerにfromのボード値を持たせる処理をしてもいいかも。fromの変更の度に更新する。
// updateに書いた方がいいかも。moveにあんまりいろいろやらせないほうがいい。
// アイテム取るのとか。そういうのも。取ったら1に戻す感じ。

// 重複しないeffect、クリアとかゲームオーバーとかは、敵倒すときのとは区別すべき。
// this.stopEffectとかして別に用意してupdateとかと分けるのもそうする、感じで。

// 当たったらダメージ、一定与えると消える仕様まで作る？こっちも相手に接触するとダメージ受けたり。
// shotのバリエーション・・曲がる回数増やすとか、同時に2方向4方向とか。

// 接触はgridの情報を使う・・
// というかupdateでxとかyの情報を手に入れてrenderとかで使う・・衝突判定は
// |x1-x2| < 1 && |y1-y2| < 1とシンプルになる。
// 今回ブリンクは無しで。ガンガン当ててガンガン減らしたい。こっちはブリンクありで。

// shotについて走らせて一つでもenemyに当たったら消滅する感じ。
// とりあえず当たったら消すことにしようっと。
