// 未確定マスで、上下左右を見たとき、1のマスがあるものを考える（他はとりあえずスルー）
// その1のマスの上下左右を見て0が2つ以上あったらその1のマスは0にできない。
// 0が1つもない場合も。1つだけの時、そこを割る（0にする）。そして、未確定マスから作った迷路をそこでつなげる感じ。
// で、valueもちゃんと計算。そのうえで、割った先の0マスのvalueに対し、壊した壁のvalueをそれ+1にして、そこから先の
// マスのvalueもそれ+2をすべて加えて再計算する感じかなぁ。
// ていうかvalueの初期値を+2にすればいいんでしょ・・createMazeにvalueの初期値の情報を加えましょう。デフォルトは0で。
// createPath(3, 3, 0)から始める。createMaze(3, 3)はcreatePath(3, 3, 0)から始める。
// そして-1が残ったら、そこを走査して、上下左右で1マスがある-1マスのうち、それらの1マスの中に上下左右で
// 0マスがひとつだけのものがあるものを探す。あればその0マスのvalueに対して1マスのvalueを+1とし、
// originの-1マスを(x, y)としてcreateMaze(x, y, v + 2)する。んー・・

// 詳細
// restマスで、その上下左右の1マスのうち、上下左右の0マスがひとつしかないもの、が、あるもの、を、探す。
// すべてのrestマスが条件を満たさないならrestマスをすべて1にしてbreak.
// あるならうち一つを選び、該当する1マスを0にしてvalueを隣接0マスのvalueをv_0としてv_0+1に設定
// そしてもとのrestマスに対しcreatePath(マス.x, マス.y, v_0+2)を実行する。
// そして次のループに移る。

// うまくいった・・？？のか？？
// 失敗。また明日。

// isZero > 1に戻したらうまくいった。自分を信じないとだめだね。

// とりあえずこれで迷路ができるみたい
// いろいろあったけど何とかなってよかった
// 中を歩いてみたい
// 円でブラインドしても面白そう
// 敵を用意して倒したい
// 単純にゴール見つけて進むだけでも面白そう
// 運要素が高すぎるのは自分が面白くないから嫌だ
// さすがに32×24ともなると若干時間かかってる・・なんか工夫が必要かも

// 斜向かいが気になる？0を置くときに、というか候補を探すときに、
// 具体的にはcheck_1でisZero > 1のとき1確定にしてfalse返してる、ここで、
// isZero === 1であっても、4つの斜め方向の中に0確定があって、その方向のライン上が1確定の場合は
// 1にしてfalse. どういうことかというと・・
// for(let k = 0; k < 4; k++){
//   let m = (k + 1) % 4;
//   dx[k]とdx[m]とdx[k] + dx[m]が1, 1, 0のときhit!
// }
// ってやればそういうのを排除できる、はず。

// 位置はcellとそこからのずれ（0～1）で表現する。十字キーでdiffに変化が生じる。
// directionの方向に十字キーを押すとdiffが増え逆方向ならdiffが減る。
// 直交する方向の場合は、diffが0に近いか1に近い場合でなければ何も起こらない感じ。
// 0に近くてfromマスの上が空いてる時の上キー操作と下が空いてる時の下キー操作でdiffが減る
// 1に近くてtoマスの上が空いてる時の上キー操作と下が空いてる時の下キー操作でdiffが増える
// diffが0を下回るときに、fromマスのdirと反対方向が1確定ならその値はdiffで固定される感じ
// そこでたとえば下が空いてて下キーとか押すとtoマスとdirが然るべく変化して計算に反映されて・・

// ショットいろいろ用意したいよね
// あとtoをなくしたい。fromだけで計算できる。

// 未探索を暗くするとか。
